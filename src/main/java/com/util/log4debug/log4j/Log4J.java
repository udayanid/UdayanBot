/* Generated by Together */

package com.util.log4debug.log4j;

import it.sella.util.log4debug.impl.AbstractLog4DebugImpl;
import it.sella.util.log4debug.impl.Log4DebugProperties;
import it.sella.util.log4debug.log4j.mbean.Log4jAdmin;
import it.sella.util.management.MBeanPublisherFactory;

import java.io.File;
import java.util.Timer;
import java.util.TimerTask;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.or.RendererMap;
import org.apache.log4j.xml.DOMConfigurator;

public class Log4J extends AbstractLog4DebugImpl {
  static {
    try {
      long configurationReloadTime = Long.parseLong(Log4DebugProperties.getProperty("Log4J.implementation.log4J.reloadTime","10000"));
      configureLog4j(configurationFileName(),configurationReloadTime);
      publishMBean();
    } catch (Throwable e) {
      System.err.println("<Warning><Log4Debug.Log4J> Warning: Log4J configured as default, without reloading!!");
      e.printStackTrace();
    }
  }
  
  private static void publishMBean() {
    new Timer().schedule(new TimerTask() {
      public void run() {
        MBeanPublisherFactory.getInstance().getMBeanPublisher().publishMBean(new Log4jAdmin(),"Log4Debug", "Log4jAdmin");        
      }
    }, 1000); // 1 second wait should be sufficient...
  }

  public static String configurationFileName(){
    String primaryConfigurationFile = Log4DebugProperties.getProperty("Log4J.implementation.log4J.configuration.primary");
    String secondaryConfigurationFile = Log4DebugProperties.getProperty("Log4J.implementation.log4J.configuration.secondary");
    if (new File(primaryConfigurationFile).exists()) {
      System.out.println("<Info><Log4Debug.Log4J> Using primary Log4J configuration file:"+primaryConfigurationFile);
      return primaryConfigurationFile;
    } else if (new File(secondaryConfigurationFile).exists()) {
      System.out.println("<Info><Log4Debug.Log4J> Using secondary Log4J configuration file:"+secondaryConfigurationFile);
      return secondaryConfigurationFile;
    } else {
      throw new IllegalArgumentException("Configuration files do not exist: primary="+primaryConfigurationFile+", secondary="+secondaryConfigurationFile+"!!");
    }
  }


  private static void configureLog4j(String configurationFile,long configurationReloadTime) {
    if (configurationFile.endsWith(".properties")) {
      System.out.println("<Info><Log4Debug.configureLog4j> Using properties Log4J configuration file:"+configurationFile);
      PropertyConfigurator.configureAndWatch(configurationFile,configurationReloadTime);
    } else if (configurationFile.endsWith(".xml")) {
      System.out.println("<Info><Log4Debug.configureLog4j> Using xml Log4J configuration file:"+configurationFile);
      DOMConfigurator.configureAndWatch(configurationFile,configurationReloadTime);
    } else {
      throw new IllegalArgumentException("Unknown log4j configuration file type: "+configurationFile);
    }
  }

  public Log4J() {
  }

  private Logger logger = null;

  public void setLoggedClass( Class loggedClass){
    logger = Logger.getLogger(loggedClass);
  }

  protected  void log(int logLevel, Object msg, Throwable t) {
    switch(logLevel) {
      case LOG_LEVEL_DEBUG:
        logger.debug(msg,t);
        break;
      case LOG_LEVEL_INFO:
        logger.info(msg,t);
        break;
      case LOG_LEVEL_WARNING:
        logger.warn(msg,t);
        break;
      case LOG_LEVEL_SEVERE:
        logger.error(msg,t);
        break;
      case LOG_LEVEL_FATAL:
        logger.fatal(msg,t);
        break;
    }
  }

  protected void log(int logLevel,String msg){
    switch(logLevel) {
      case LOG_LEVEL_DEBUG:
        logger.debug(msg);
        break;
      case LOG_LEVEL_INFO:
        logger.info(msg);
        break;
      case LOG_LEVEL_WARNING:
        logger.warn(msg);
        break;
      case LOG_LEVEL_SEVERE:
        logger.error(msg);
        break;
      case LOG_LEVEL_FATAL:
        logger.fatal(msg);
        break;
    }
  }

  protected boolean isLoggable(int logLevel){
    switch(logLevel) {
      case LOG_LEVEL_DEBUG:
        return logger.isDebugEnabled();
      case LOG_LEVEL_INFO:
        return logger.isInfoEnabled();
      case LOG_LEVEL_WARNING:
        return logger.isEnabledFor(Level.WARN);
      case LOG_LEVEL_SEVERE:
        return logger.isEnabledFor(Level.ERROR);
      case LOG_LEVEL_FATAL:
        return logger.isEnabledFor(Level.FATAL);
      default:
        throw new IllegalArgumentException("Wrong logLevel: "+logLevel);
    }
  }

  private static final RendererMap rendererMap=new RendererMap();

  protected String render(Object obj) {
    return rendererMap.findAndRender(obj);
  }
}
